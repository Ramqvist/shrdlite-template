import gnu.prolog.term.AtomTerm;
import gnu.prolog.term.CompoundTerm;
import gnu.prolog.term.Term;

import java.util.ArrayList;
import java.util.List;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

/**
 * Allows you to interpret any tree parsed by the DCGParser, generating a list
 * of relations that describe the goal that the planner should try to reach.
 * 
 */
public class Interpreter {

	List<List<Entity>> world = new ArrayList<List<Entity>>();

	public Interpreter(JSONArray world, String holding, JSONObject objects) {
		convertFromJSON(world, objects);
	}

	/**
	 * Converts the given JSON input to a two-dimensional list of {@link Entity}
	 * objects.
	 * 
	 * @param world
	 *            A JSONArray containing the entire state of the world.
	 * @param objects
	 *            A JSONObject containing mappings that describe every valid
	 *            object in the world.
	 */
	private void convertFromJSON(JSONArray world, JSONObject objects) {
		for (int i = 0; i < world.size(); i++) {
			JSONArray stack = (JSONArray) world.get(i);

			ArrayList<Entity> column = new ArrayList<Entity>();

			for (int j = 0; j < stack.size(); j++) {
				String name = (String) stack.get(j);
				JSONObject entityDescription = (JSONObject) objects.get(name);
				Entity newEntity = new Entity((String) entityDescription.get("form"), (String) entityDescription.get("size"),
						(String) entityDescription.get("color"));
				column.add(newEntity);
			}

			this.world.add(column);
		}
		Debug.print("World Representation");
		Debug.print(this.world);
		Debug.print();
	}

	List<Relation> relations;

	/**
	 * Interprets the given tree, returning a (possibly empty) list of goals
	 * that satisfy the "meaning" of the given tree.
	 * 
	 * @param tree
	 *            A DCGParser tree of an utterance parsed by the Shrdlite
	 *            grammar.
	 * @return A (possibly empty) list of goals that model the goal of the given
	 *         tree.
	 */
	public List<Goal> interpret(Term tree) {
		List<Goal> goalList = new ArrayList<Goal>();
		relations = new ArrayList<>();

		Debug.print("=================");
		Debug.print("START OF INTERPRET");
		Debug.print();

		try {
			walkTree(tree);
			goalList.add(new Goal(relations));
		} catch (InterpretationException e) {
			Debug.print(e);
		}

		Debug.print();
		Debug.print("END OF INTERPRET");
		Debug.print("================");
		Debug.print();

		if (goalList.size() > 0)
			Debug.print(goalList.get(0));
		else
			Debug.print("No goal could be produced.");

		Debug.print();

		return goalList;
	}

	/*
	 * This is simply to avoid having to let walkTree have a second parameter
	 * that is null most of the time. Could perhaps be done better.
	 */
	private Relation givenRelation;

	/*
	 * These booleans are used to make sure that the correct relations are
	 * generated in the walkTree method. The logic is as follows:
	 * 
	 * As a rule, we only create and save relations if they are created in the
	 * "take", "put" and "move" methods.
	 * 
	 * However, sometimes we need to generate more than one relation, e.g. for
	 * the utterance "put the white ball in a red box on the floor" there is no
	 * red box on the floor. However, there is a red box that could be put on
	 * the floor. These booleans are then used to make sure that a relation that
	 * says that in addition to having the white ball be inside a red box, that
	 * red box should be on top of the floor.
	 */
	private boolean relativeChild = false, moveRelation = false;

	/**
	 * Recursively walks the given tree, generating a list of relations that
	 * describe the goal of the given tree.
	 * 
	 * @param term
	 *            A DCGParser representation of an utterance parsed by the
	 *            Shrdlite grammar.
	 * @return The final relation generated by this function.
	 * @throws InterpretationException
	 *             Thrown when the given tree doesn't match anything in the
	 *             world, or when the given tree doesn't satisfy the given
	 *             constraints of the world.
	 */
	public Object walkTree(Term term) throws InterpretationException {
		Relation relation, finalRelation;
		Entity entity;

		if (term instanceof CompoundTerm) {
			CompoundTerm cterm = (CompoundTerm) term;
			switch (cterm.tag.functor.toString()) {
			case "take":
				/*
				 * Take has one child, which is always either floor,
				 * basic_entity or relative_entity.
				 */
				Debug.print("saw take");
				entity = (Entity) walkTree(cterm.args[0]);
				/*
				 * TODO: HOW DO WE EXPLAIN THIS AS A RELATION?
				 * 
				 * Quote from the course page:
				 * "For the take and put commands, the procedure is similar but differentâ€¦"
				 */
				break;
			case "move":
				/*
				 * Move has two children. The left child is always either floor,
				 * basic_entity or relative_entity. For us, this means it is
				 * always an Entity.
				 * 
				 * The right child is always relative. For us, this means it is
				 * always a Relation.
				 */
				Debug.print("saw move");
				entity = (Entity) walkTree(cterm.args[0]);
				moveRelation = true;
				relation = (Relation) walkTree(cterm.args[1]);
				moveRelation = false;
				if (Relation.matchEntityAndRelationExact(entity, relation, world).isEmpty()) {
					if (!Relation.matchEntityAndRelation(entity, relation, world).isEmpty()) {
						throw new InterpretationException("No need to do more, world is already matching relation.");
					}
				}

				finalRelation = new Relation(entity, relation.getEntityB(), relation.getType());
				relations.add(finalRelation);

				/*
				 * Here we check if this relation makes sense in the world. This
				 * check is done by another class, ConstraintCheck. No need to
				 * clutter up our code with checking logic here.
				 */
				if (!ConstraintCheck.isValidRelations(relations)) {
					throw new InterpretationException("The created relation " + relations + " don't match the rules of the world.");
				}

				Debug.print("MOVE: Added new relation to relations: " + finalRelation);
				return finalRelation;
			case "relative":
				/*
				 * Relative has two children. The left child is always a
				 * relation type.
				 * 
				 * The right child is always either floor, basic_entity or
				 * relative_entity. For us, this means it is always an Entity.
				 */
				Debug.print("saw relative");
				Relation.TYPE relationType = (Relation.TYPE) walkTree(cterm.args[0]);
				relativeChild = true;
				entity = (Entity) walkTree(cterm.args[1]);
				return new Relation(new Entity(), entity, relationType);
			case "basic_entity":
				/*
				 * Basic_entity has two children. The left child is always a
				 * quantifier.
				 * 
				 * The right child is always an object. For us, this means it is
				 * an Entity.
				 */
				Debug.print("saw basic_entity");
				walkTree(cterm.args[0]);
				entity = (Entity) walkTree(cterm.args[1]);
				return entity;
			case "relative_entity":
				/*
				 * Relative_entity has three children. The left child is always
				 * a quantifier.
				 * 
				 * The middle child is always relative. For us, this means it is
				 * a Relation.
				 * 
				 * The right child is always an object. For us, this means it is
				 * an Entity.
				 */
				Debug.print("saw relative_entity");
				walkTree(cterm.args[0]);
				givenRelation = relation = (Relation) walkTree(cterm.args[2]);
				entity = (Entity) walkTree(cterm.args[1]);
				finalRelation = new Relation(entity, relation.getEntityB(), relation.getType());

				/*
				 * If this relative_entity has been reached from the right child
				 * of "move" and is a child of relative, we should save this
				 * relation.
				 */
				if (relativeChild && moveRelation)
					relations.add(finalRelation);

				/*
				 * Here we check if this relation makes sense in the world. This
				 * check is done by another class, ConstraintCheck. No need to
				 * clutter up our code with checking logic here.
				 */
				if (!ConstraintCheck.isValidRelations(relations))
					throw new InterpretationException("The created relation " + relations + " don't match the rules of the world.");

				relativeChild = false;
				return finalRelation.getEntityA();
			case "object":
				/*
				 * Object always has three children. The left child is the size
				 * of the object.
				 * 
				 * The middle child is the form of the object.
				 * 
				 * The right child is the color of the object.
				 * 
				 * When this case has been reached from a relative_entity, the
				 * relation in relative_entity must be given to in this case so
				 * that we here can correctly decide what object we want.
				 * 
				 * This is done by setting the givenRelation object to the given
				 * relation.
				 */
				Debug.print("saw object");
				entity = new Entity(cterm.args[0].toString(), cterm.args[1].toString(), cterm.args[2].toString());

				/*
				 * Check if any entity matched the given relation, and act
				 * accordingly.
				 */
				List<Entity> matchedEntities = Relation.matchEntityAndRelation(entity, givenRelation, world);
				Entity returnEntity = entity;
				Debug.print(returnEntity);
				if (matchedEntities.isEmpty()) {
					if (givenRelation == null) {
						throw new InterpretationException("[" + entity + "] does not match anything in the world.");
					} else {
						returnEntity = matchEntity(world, givenRelation);
						if (returnEntity == null) {
							throw new InterpretationException("[" + entity + "] does not match anything in the world.");
						}
					}
					givenRelation.setEntityA(entity);
					// } else if (matchedEntities.size() > 1) {
					// // TODO: Handle Ambiguity Error in some fancy way.
				} else {
					returnEntity = matchedEntities.get(0);
				}
				Debug.print(returnEntity);

				Debug.print("Success: [" + entity + "] exists in the world as [" + returnEntity + "].");
				givenRelation = null; // Reset the givenRelation value.
				return returnEntity;
			}
		} else if (term instanceof AtomTerm) {
			AtomTerm aterm = (AtomTerm) term;
			switch (aterm.value) {
			case "floor":
				Debug.print("saw floor");
				return new Entity(Entity.FORM.FLOOR, Entity.SIZE.UNDEFINED, Entity.COLOR.UNDEFINED);
			case "the":
				Debug.print("saw the");
				// "The" means that there should only be one item that matches
				// the description. If more than one item matches the
				// description, we should ask clarification question(s):
				break;
			case "any":
				Debug.print("saw any");
				// "Any" should work as this currently does.
				break;
			case "all":
				Debug.print("saw all");
				// "All" should create one relation for each item that matches
				// the description.
				break;
			}
			// This static method handles the parsing of type values.
			return Relation.parseType(aterm.value);
		}
		Debug.print();
		return null;
	}

	/**
	 * Returns the first entity that matches the given relation in the given
	 * world.
	 * 
	 * @param world
	 *            a 2D list of entities.
	 * @param givenRelation
	 *            a Relation that describes the relation that the returned
	 *            entity should match.
	 * @return the matching entity or null if no entity matches the given
	 *         relation.
	 */
	private Entity matchEntity(List<List<Entity>> world, Relation givenRelation) {
		for (List<Entity> column : world) {
			for (Entity cEntity : column) {
				if (cEntity.equals(givenRelation.getEntityA())) {
					return cEntity;
				}
			}
		}
		return null;
	}

	public class InterpretationException extends Exception {

		private static final long serialVersionUID = 2280978916235342656L;

		public InterpretationException(String message) {
			super(message);
		}

	}

}

import gnu.prolog.term.AtomTerm;
import gnu.prolog.term.CompoundTerm;
import gnu.prolog.term.Term;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

/**
 * Allows you to interpret any tree parsed by the DCGParser, generating a list
 * of relations that describe the goal that the planner should try to reach.
 * 
 */
public class InterpreterNew {

	List<List<Entity>> world = new ArrayList<List<Entity>>();
	Entity heldEntity;

	public InterpreterNew(JSONArray world, String holding, JSONObject objects) throws IOException {
		convertFromJSON(world, objects, holding);
	}

	/**
	 * Converts the given JSON input to a two-dimensional list of {@link Entity}
	 * objects.
	 * 
	 * @param world
	 *            A JSONArray containing the entire state of the world.
	 * @param objects
	 *            A JSONObject containing mappings that describe every valid
	 *            object in the world.
	 * @throws IOException
	 */
	private void convertFromJSON(JSONArray world, JSONObject objects, String holding) throws IOException {
		for (int i = 0; i < world.size(); i++) {
			JSONArray stack = (JSONArray) world.get(i);

			ArrayList<Entity> column = new ArrayList<Entity>();

			for (int j = 0; j < stack.size(); j++) {
				String name = (String) stack.get(j);
				JSONObject entityDescription = (JSONObject) objects.get(name);
				Entity newEntity = new Entity((String) entityDescription.get("form"), (String) entityDescription.get("size"),
						(String) entityDescription.get("color"));
				column.add(newEntity);
			}

			this.world.add(column);
		}
		JSONToProlog(world, objects);

		if (holding != null) {
			JSONObject description = (JSONObject) objects.get(holding);
			heldEntity = new Entity((String) description.get("form"), (String) description.get("size"), (String) description.get("color"));
		}

		Debug.print("World Representation");
		Debug.print(this.world);
		Debug.print();

		Debug.print("Held Entity");
		if (heldEntity != null) {
			Debug.print(heldEntity);
		} else {
			Debug.print("Nothing");
		}
		Debug.print();
	}

	public void JSONToProlog(JSONArray JSONWorld, JSONObject jObjects) throws IOException {

		PrintWriter world = new PrintWriter("world.pl", "UTF-8");
		PrintWriter objects = new PrintWriter("entities.pl", "UTF-8");

		String worldWithQuotesRemoved = JSONWorld.toString().replace("\"", "");

		world.write("world(");
		world.write(worldWithQuotesRemoved);
		world.write(").");

		world.close();

		for (Object key : jObjects.keySet()) {
			String id = key.toString();
			Object value = jObjects.get(key);
			int index = 0;
			String str = value.toString();
			int begin = str.indexOf(":\"") + 2;
			int end = str.indexOf("\",");
			index = end + 1;

			String form = str.substring(begin, end);

			begin = str.indexOf(":\"", index) + 2;
			end = str.indexOf("\",", index);
			index = end + 1;

			String color = str.substring(begin, end);

			begin = str.indexOf(":\"", index) + 2;
			end = str.indexOf("\"}", index);

			String size = str.substring(begin, end);

			objects.write("entity(" + id + ",");
			objects.write(form + ",");
			objects.write(size + ",");
			objects.write(color + ").\n");
		}
		objects.close();
	}

	private List<Relation> relations;
	private List<Goal> goalList;

	/**
	 * Interprets the given tree, returning a (possibly empty) list of goals
	 * that satisfy the "meaning" of the given tree.
	 * 
	 * @param tree
	 *            A DCGParser tree of an utterance parsed by the Shrdlite
	 *            grammar.
	 * @return A (possibly empty) list of goals that model the goal of the given
	 *         tree.
	 */
	public List<Goal> interpret(Term tree) {
		goalList = new ArrayList<>();
		relations = new ArrayList<>();

		Debug.print("=================");
		Debug.print("START OF INTERPRET");
		Debug.print();

		try {
			walkTree(tree);
		} catch (InterpretationException e) {
			Debug.print(e);
		}

		Debug.print();
		Debug.print("END OF INTERPRET");
		Debug.print("================");
		Debug.print();

		if (goalList.size() > 0) {
			for (Goal goal : goalList) {
				Debug.print(goal);
			}
		} else {
			Debug.print("No goal could be produced.");
		}
		Debug.print();
		return goalList;
	}

	/**
	 * Recursively walks the given tree, generating a list of relations that
	 * describe the goal of the given tree.
	 * 
	 * @param term
	 *            A DCGParser representation of an utterance parsed by the
	 *            Shrdlite grammar.
	 * @return The final relation generated by this function.
	 * @throws InterpretationException
	 *             Thrown when the given tree doesn't match anything in the
	 *             world, or when the given tree doesn't satisfy the given
	 *             constraints of the world.
	 */
	public Object walkTree(Term term) throws InterpretationException {
		if (term instanceof CompoundTerm) {
			CompoundTerm cterm = (CompoundTerm) term;
			switch (cterm.tag.functor.toString()) {
			case "take":
				return take(cterm);
			case "move":
				return move(cterm);
			case "relative":
				return relative(cterm);
			case "basic_entity":
				return basicEntity(cterm);
			case "relative_entity":
				return relativeEntity(cterm);
			case "object":
				return object(cterm);
			}
		} else if (term instanceof AtomTerm) {
			AtomTerm aterm = (AtomTerm) term;
			switch (aterm.value) {
			case "floor":
				Debug.print("saw floor");
				List<List<Entity>> tempListList = new ArrayList<List<Entity>>();
				List<Entity> tempList = new ArrayList<Entity>();
				tempList.add(new Entity(Entity.FORM.FLOOR, Entity.SIZE.UNDEFINED, Entity.COLOR.UNDEFINED));
				tempListList.add(tempList);
				return tempListList;
			case "the":
				Debug.print("saw the");
				return "the";
			case "any":
				Debug.print("saw any");
				return "any";
			case "all":
				Debug.print("saw all");
				return "all";
			}
			// This static method handles the parsing of type values.
			return Relation.parseType(aterm.value);
		}
		Debug.print();
		return null;
	}

	/**
	 * Take has one child, which is always either floor, basic_entity or
	 * relative_entity.
	 * 
	 * @param cterm
	 *            The node to be parsed.
	 * @return Null.
	 * @throws InterpretationException
	 *             if no matching entities could be found.
	 */
	private Object take(CompoundTerm cterm) throws InterpretationException {
		Debug.print("saw take");
		List<List<Entity>> matchedEntitiesList = (List<List<Entity>>) walkTree(cterm.args[0]);
		for (List<Entity> matchedEntities : matchedEntitiesList) {
			for (Entity matchedEntity : matchedEntities) {
				if (matchedEntity.getForm() == Entity.FORM.FLOOR) {
					throw new InterpretationException("You can't take the floor, stupid.");
				}

				goalList.add(new Goal(new Relation(matchedEntity, new Entity(), Relation.TYPE.HELD)));
			}
		}
		return null;
	}

	/**
	 * Move has two children. The left child is always either floor,
	 * basic_entity or relative_entity. For us, this means it is always an
	 * Entity.
	 * 
	 * The right child is always relative. For us, this means it is always a
	 * Relation.
	 * 
	 * @param cterm
	 *            The node to be parsed.
	 * @return Null.
	 * @throws InterpretationException
	 *             if no matching entities could be found.
	 */
	private Object move(CompoundTerm cterm) throws InterpretationException {
		/*
		 * 
		 */
		Debug.print("saw move");

		List<List<Entity>> matchedEntitiesList = (List<List<Entity>>) walkTree(cterm.args[0]);
		Debug.print("move: matchedEntitiesList: " + matchedEntitiesList);

		List<List<Relation>> relationsList = (List<List<Relation>>) walkTree(cterm.args[1]);
		Debug.print("move: relationsList: " + relationsList);
		
		for (List<Entity> matchedEntities : matchedEntitiesList) {
			for (List<Relation> relationList : relationsList) {
				List<Relation> goalRelationList = new ArrayList<>();
				for (Entity matchedEntity : matchedEntities) {
//					goalRelationList = new ArrayList<>();
					for (Relation relation : relationList) {
						Relation newRelation = new Relation(matchedEntity, relation.getEntityB(), relation.getType());
						if (checkRelation(newRelation, goalRelationList)) {
							goalRelationList.add(newRelation);
						}
					}
				}
				Debug.print(goalRelationList);
//				for (List<Relation> relationList : relationsList) {
				int countOfRelationsToSelf = 0;
				for (Entity matchedEntity : matchedEntities) {
					for (Relation relation : relationList) {
						if (relation.getEntityB().equalsExact(matchedEntity)) {
							Debug.print(matchedEntity + " exists in relationList.");
							countOfRelationsToSelf++;
						}
					}
				}
				if (goalRelationList.size() < relationList.size() - countOfRelationsToSelf) {
					goalRelationList.clear();
				}
//				}
				if (!goalRelationList.isEmpty()) {
					goalList.add(new Goal(goalRelationList));
				}
			}
		}
		return null;
	}

	/**
	 * Checks if the given relation is OK in regards to a given list of
	 * relations.
	 * 
	 * @param relation
	 *            The Relation to check.
	 * @param relationList
	 *            A list of relation to check the relation against.
	 * @return True if the given relation is OK, otherwise false.
	 */
	private boolean checkRelation(Relation relation, List<Relation> relationList) {
		if (!ConstraintCheck.isValidRelation(relation)) {
			return false;
		}
		if (relation.getType() == Relation.TYPE.INSIDE || relation.getType() == Relation.TYPE.ON_TOP_OF) {
			for (Relation anotherRelation : relationList) {
				if (anotherRelation.getType() == relation.getType()) {
					if (anotherRelation.getEntityB().equalsExact(relation.getEntityB())
							|| anotherRelation.getEntityA().equalsExact(relation.getEntityA())) {
						if (anotherRelation.getEntityB().getForm() != Entity.FORM.FLOOR
								&& relation.getEntityB().getForm() != Entity.FORM.FLOOR) {
							Debug.print("checkRelation: " + relation + " is false cause " + anotherRelation + " already exists.");
							return false;
						}
					}
				}
			}
		}
		return true;
	}

	/**
	 * Relative has two children. The left child is always a relation type.
	 * 
	 * The right child is always either floor, basic_entity or relative_entity.
	 * For us, this means it is always an Entity.
	 * 
	 * @param cterm
	 *            The node to be parsed.
	 * @return A list of relations.
	 * @throws InterpretationException
	 *             if no matching entities could be found.
	 */
	private Object relative(CompoundTerm cterm) throws InterpretationException {
		// TODO: This should ONLY return a list of relations, one for each item
		// returned from the right child.
		Debug.print("saw relative");
		Relation.TYPE relationType = (Relation.TYPE) walkTree(cterm.args[0]);
		Debug.print("relative: relationType: " + relationType);

		List<List<Entity>> matchedEntitiesList = (List<List<Entity>>) walkTree(cterm.args[1]);
		Debug.print("relative: matchedEntitiesList: " + matchedEntitiesList);

		List<List<Relation>> relationsList = new ArrayList<List<Relation>>();
		for (List<Entity> matchedEntities : matchedEntitiesList) {
			List<Relation> tempList = new ArrayList<>();
			for (Entity someEntity : matchedEntities) {
				tempList.add(new Relation(new Entity(), someEntity, relationType));
			}
			relationsList.add(tempList);
		}
		Debug.print("relative: relationsList: " + relationsList);
		return relationsList;
	}

	/**
	 * Basic_entity has two children. The left child is always a quantifier.
	 * 
	 * The right child is always an object. For us, this means it is an Entity.
	 * 
	 * @param cterm
	 *            The node to be interpreted.
	 * @return A list of all matching entities.
	 * @throws InterpretationException
	 *             if no matching entities could be found.
	 */
	private Object basicEntity(CompoundTerm cterm) throws InterpretationException {
		// TODO: This should only return the entities that we get from "object",
		// also check the quantifier and change which entities to return.
		Debug.print("saw basic_entity");
		String quantifier = (String) walkTree(cterm.args[0]);
		Debug.print("basicEntity: quantifier: " + quantifier);

		List<Entity> matchedEntities = (List<Entity>) walkTree(cterm.args[1]);
		Debug.print("basicEntity: matchedEntities: " + matchedEntities);

		List<List<Entity>> matchedEntitiesPruned = new ArrayList<List<Entity>>();
		if (quantifier.equals("the")) {
			Entity temp = matchedEntities.get(0);
			matchedEntities.clear();
			matchedEntities.add(temp);
			matchedEntitiesPruned.add(matchedEntities);
		} else if (quantifier.equals("any")) {
			for (Entity matchedEntity : matchedEntities) {
				List<Entity> tempList = new ArrayList<>();
				tempList.add(matchedEntity);
				matchedEntitiesPruned.add(tempList);
			}
		} else if (quantifier.equals("all")) {
			matchedEntitiesPruned.add(matchedEntities);
		}
		Debug.print("basicEntity: " + quantifier + ": picked " + matchedEntitiesPruned);
		return matchedEntitiesPruned;
	}

	/**
	 * Relative_entity has three children. The left child is always a
	 * quantifier.
	 * 
	 * The middle child is always an object. For us, this means it is an Entity.
	 * 
	 * The right child is always relative. For us, this means it is a Relation.
	 * 
	 * @param cterm
	 *            The node to be interpreted.
	 * @return A list of all matching entities.
	 * @throws InterpretationException
	 *             if no entities could be found.
	 */
	private Object relativeEntity(CompoundTerm cterm) throws InterpretationException {
		Debug.print("saw relative_entity");
		String quantifier = (String) walkTree(cterm.args[0]);
		Debug.print("relativeEntity: quantifier: " + quantifier);

		List<List<Relation>> relationsList = (List<List<Relation>>) walkTree(cterm.args[2]);
		Debug.print("relativeEntity: relationList: " + relationsList);

		List<Entity> matchedEntities = (List<Entity>) walkTree(cterm.args[1]);
		Debug.print("relativeEntity: matchedEntities pre-prune: " + matchedEntities);

		// We can first prune away all the entities that cannot be applied to
		// any of the relations. Balls under objects etc.
		List<Entity> tempEntityList = new ArrayList<>();
		for (List<Relation> relationList : relationsList) {
			tempEntityList.addAll(matchEntitiesAndRelations(world, matchedEntities, relationList, heldEntity));
			Debug.print("relativeEntity: tempEntityList: " + tempEntityList);
		}
		matchedEntities = tempEntityList;
		Debug.print("relativeEntity: matchedEntities post-prune: " + matchedEntities);

		if (matchedEntities.isEmpty()) {
			throw new InterpretationException("No objects matching " + relationsList + " could be found.");
		}

		List<List<Entity>> matchedEntitiesPruned = new ArrayList<List<Entity>>();
		if (quantifier.equals("the")) {
			Entity temp = matchedEntities.get(0);
			matchedEntities.clear();
			matchedEntities.add(temp);
			matchedEntitiesPruned.add(matchedEntities);
		} else if (quantifier.equals("any")) {
			for (Entity matchedEntity : matchedEntities) {
				List<Entity> tempList = new ArrayList<>();
				tempList.add(matchedEntity);
				matchedEntitiesPruned.add(tempList);
			}
		} else if (quantifier.equals("all")) {
			matchedEntitiesPruned.add(matchedEntities);
		}
		Debug.print("relativeEntity: " + quantifier + ": picked " + matchedEntitiesPruned);
		return matchedEntitiesPruned;
	}

	/**
	 * Object always has three children. The left child is the size of the
	 * object.
	 * 
	 * The middle child is the form of the object.
	 * 
	 * The right child is the color of the object.
	 * 
	 * @param cterm
	 *            The node to be interpreted.
	 * @return A list of matching entities.
	 * @throws InterpretationException
	 *             if no entities could be matched.
	 */
	private Object object(CompoundTerm cterm) throws InterpretationException {
		Debug.print("saw object");
		Entity entity = new Entity(cterm.args[0].toString(), cterm.args[1].toString(), cterm.args[2].toString());
		List<Entity> matchedEntities = matchEntity(world, entity);
		Debug.print("object: matchedEntities: " + matchedEntities);

		if (matchedEntities.isEmpty()) {
			throw new InterpretationException(entity + " does not match anything in the world.");
		}

		return matchedEntities;
	}

	/**
	 * This is called to add an item to the relation list. It makes sure that
	 * there are no relations created where an object is related to itself.
	 * 
	 * @param relation
	 *            The relation to (maybe) add.
	 */
	private void addToRelations(Relation relation) {
		if (!relation.getEntityA().equalsExact(relation.getEntityB())) {
			relations.add(relation);
		}
	}

	private List<Entity> matchEntity(List<List<Entity>> world, Entity entity) {
		List<Entity> matchedEntities = new ArrayList<>();
		for (List<Entity> column : world) {
			for (Entity cEntity : column) {
				if (cEntity.equals(entity)) {
					matchedEntities.add(cEntity);
				}
			}
		}
		if (heldEntity != null && heldEntity.equals(entity)) {
			matchedEntities.add(heldEntity);
		}
		return matchedEntities;
	}

	private List<Entity> matchEntitiesAndRelations(List<List<Entity>> world, List<Entity> entities, List<Relation> relations,
			Entity heldEntity) {
		List<Entity> matchedEntities = new ArrayList<>();
		for (Entity entity : entities) {
			boolean matched = true;
			for (Relation relation : relations) {
				if (!checkEntityAndRelation(world, entity, relation)) {
					matched = false;
				}
			}
			if (matched) {
				matchedEntities.add(entity);
			}
		}
		for (Entity entity : entities) {
			boolean matched = true;
			if (heldEntity != null && heldEntity.equals(entity)) {
				for (Relation relation : relations) {
					if (!checkEntityAndRelation(world, heldEntity, relation)) {
						matched = false;
					}
				}
				if (matched) {
					matchedEntities.add(entity);
				}
			}
		}
		return matchedEntities;
	}

	private boolean checkEntityAndRelation(List<List<Entity>> world, Entity entity, Relation relation) {
		for (List<Entity> column : world) {
			if (relation.getType().equals(Relation.TYPE.ON_TOP_OF)) {
				if (relation.getEntityB().getForm().equals(Entity.FORM.FLOOR)) {
					// The floor is a special case, since it is
					// not represented in our world.
					if (column.indexOf(entity) == 0) {
						return true;
					}
				} else if (!relation.getEntityB().getForm().equals(Entity.FORM.BOX)) {
					// An entity is never on top of a box.
					// Check for entities below this entity.
					if (column.contains(entity) && column.indexOf(entity) > 0) {
						if (column.get(column.indexOf(entity) - 1).equals(relation.getEntityB())) {
							return true;
						}
					}
				}
			} else if (relation.getType().equals(Relation.TYPE.INSIDE)) {
				// Entities are always inside boxes, nothing
				// else. Only boxes.
				if (relation.getEntityB().getForm().equals(Entity.FORM.BOX)) {
					if (column.contains(entity) && column.indexOf(entity) > 0) {
						if (column.get(column.indexOf(entity) - 1).equals(relation.getEntityB())) {
							return true;
						}
					}
				}
			} else if (relation.getType().equals(Relation.TYPE.ABOVE)) {
				// Check for entities below this entity.
				if (column.contains(entity)) {
					for (int i = column.indexOf(entity); i >= 0; i--) {
						if (column.get(i).equals(relation.getEntityB())) {
							return true;
						}
					}
				}
			} else if (relation.getType().equals(Relation.TYPE.UNDER)) {
				// Check for entities above this entity.
				if (column.contains(entity)) {
					for (int i = column.indexOf(entity) + 1; i < column.size() - 1; i++) {
						if (column.get(i).equals(relation.getEntityB())) {
							Debug.print(entity + " is UNDER " + relation.getEntityB());
							return true;
						}
					}
				}
			} else if (relation.getType().equals(Relation.TYPE.BESIDE)) {
				// Relation says the entity should be beside
				// another entity, is it?
				if (column.contains(entity)) {
					if (world.indexOf(column) + 1 < world.size()) {
						// Is it to the right of this entity?
						if (world.get(world.indexOf(column) + 1).contains(relation.getEntityB())) {
							return true;
						}
					} else if (world.indexOf(column) - 1 >= 0) {
						// Is is to the left of this entity?
						if (world.get(world.indexOf(column) - 1).contains(relation.getEntityB())) {
							return true;
						}
					}
				}
			} else if (relation.getType().equals(Relation.TYPE.LEFT_OF)) {
				// Relation says the entity should be left of
				// another entity, is it?
				if (column.contains(entity)) {
					for (int i = world.indexOf(column) + 1; i < world.size(); i++) {
						if (world.get(i).contains(relation.getEntityB())) {
							return true;
						}
					}
				}
			} else if (relation.getType().equals(Relation.TYPE.RIGHT_OF)) {
				// Relation says the entity should be right of
				// another entity, is it
				if (column.contains(entity)) {
					for (int i = world.indexOf(column) - 1; i >= 0; i--) {
						if (world.get(i).contains(relation.getEntityB())) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	public class InterpretationException extends Exception {

		private static final long serialVersionUID = 2280978916235342656L;

		public InterpretationException(String message) {
			super(message);
		}

	}

}
